---
title: 第一章--操作系统概述
date: 2025-10-23 15:31:38
categories: 笔记
tags: ['操作系统']
---
迟序之数，非出神怪，有形可检，有数可推。——祖冲之

<!-- more -->

# 操作系统的概念

**操作系统**(Operating System, OS)是指**控制和管理整个计算机系统的硬件和软件资源**，并合理地**组织调度计算机的工作和资源的分配**；以**提供给用户和其他软件方便的接口和环境**；它是计算机系统中最基本的软件系统。

组成部分：

![1761205410236](image/第一章--操作系统概述_20251023_153138/1761205410236.webp)

1. 系统资源的管理者
   * 处理机管理
   * 存储器管理
   * 文件管理
   * 设备管理
2. 向上层提供方便易用的服务
   * 封装思想：操作系统把**复杂的硬件功能**封装为相对**简单易用**的服务，使得用户能方便地使用计算机，无需关心底层硬件原理。
   * 提供的服务：
     * GUI(图形化用户接口)
     * 命令接口：
       * 联机命令接口：交互式命令接口(在cmd中一个个输入命令)
       * 脱机命令接口：批处理命令接口(`.bat`文件)
       * 程序接口：可以在**程序中**进行系统调用来使用程序接口。只能通过代码调用。(`printf()`方法)
3. 作为最接近硬件的层次
   * 实现对硬件机器的拓展
     > 操作系统组织协调各个硬件(CPU、内存、硬盘等)实现更多更复杂的功能
     >

> 补充概念：
>
> * 裸机：没有任何软件支持的计算机。
> * 虚拟机：把覆盖了软件的机器称为**扩充机器**，又称**虚拟机**。

![1761206672074](image/第一章--操作系统概述_20251023_153138/1761206672074.webp)

# 操作系统的特征

## 并发

> **并发**：指**两个或多个事件**在同一事件间隔发生，这些事件宏观上是同时发生的，但微观上是**交替**发生的。
> **并行**：两个或多个事件在同一时刻发生。

**操作系统的并发性**：在计算机系统中，同时运行着多个程序，这些程序宏观上是同时运行的，而微观上看是交替运行的。

> CPU：
>
> * 单核：同一时刻只能执行一个程序，各个程序只能**并发**的执行。
> * 多核：同一时刻可以同时执行多个程序，每个**核心可以执行一个程序**，多个程序可以**并行**的执行。

并发特性是与操作系统一起诞生的，是操作系统一个最基本的特性。

## 共享

**共享**：资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

方式：

* **互斥共享方式**：虽然可以提供给多个进程使用，但**一个时间段内只允许一个进程访问该资源**。
  * 例子：手机摄像头只能同时被一个程序访问。
* **同时共享方式**：**允许同一个时间段内由多个进程"同时"对它进行访问。**
  * 例子：两个程序都在发送文件，交替从硬盘中访问数据。

> "同时"：往往是宏观的，微观可能是交替访问的。

## 虚拟

**虚拟**：把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的。

分类：

* **时分复用技术**：分时使用同一资源
  * 例子：**CPU时间调度**，将 CPU 的运行时间划分为一个个时间片，每个进程轮流占用 CPU。
* **空分复用技术**：空间划分并行使用
  * 例子：**虚拟磁盘**，一块物理磁盘被划分为多个逻辑卷（如 C、D、E 盘），用户感觉有多个独立磁盘。

## 异步

**异步**：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可预知的速度前进，这就是程序的异步性。

![1761208649419](image/第一章--操作系统概述_20251023_153138/1761208649419.webp)

* 并发和共享互为存在条件。
* 没用并发和共享，就谈不上虚拟化和异步。因此共享和并发是操作系统最基本的两个特征。

# os发展与分类

## 手工操作系统

![1761209479371](image/第一章--操作系统概述_20251023_153138/1761209479371.webp)

## 单道批处理系统

引入**脱机输入输出**，由监督程序负责作业的输入输出。

![1761209542325](image/第一章--操作系统概述_20251023_153138/1761209542325.webp)

## 多道批处理系统(操作系统诞生)

![1761209592613](image/第一章--操作系统概述_20251023_153138/1761209592613.webp)

支持**并发执行**，**共享**CPU资源。

## 分时操作系统

计算机以时间片为单位轮流为各个用户/作业服务，各个用户**可以**通过终端与计算机**进行交互**。

缺点：不能处理紧急任务

![1761209764875](image/第一章--操作系统概述_20251023_153138/1761209764875.webp)

## 实时操作系统

能够优先处理一些紧急任务，某些紧急任务不需要时间片排队。

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并要**在严格的时限内处理完事件**。

特点：

* **及时性**
* **可靠性**

分类：

* **硬实时系统**：必须在**绝对严格**的规定时间内完成处理
* **软实时系统**：能接受**偶尔违反**时间规定。

![1761210072086](image/第一章--操作系统概述_20251023_153138/1761210072086.webp)

# 操作系统的运行机制

![1761218434432](image/第一章--操作系统概述_20251023_153138/1761218434432.webp)

> **指令**：处理器(CPU)能识别、执行的最基本的命令。
>
> 注意：此处的指令不是在cmd，shell等终端中输入的命令。而是cpu直接识别执行的一条条指令，类似汇编代码中的一行。

## 内核态与用户态

操作系统(OS)采用**双模操作**(Dual-mode operation)来确保系统安全和正常运行。双模操作的目的是保护操作系统和其他系统组件**不受错误的用户程序的侵害**，同时也防止不同用户程序之间的相互干扰。

双模操作将CPU的运行模式分为两种：(用一个**位模式**来指示当前的运行模式)

> 存储位模式的寄存器叫程序状态字寄存器PSW，其中有个二进制位

1. **内核态**(Kernel Mode)：

   * **模式位**：0
   * 操作系统(OS)和特权指令在CPU上运行
   * CPU在系统引导启动时，首先以内核态开始运行
   * **模式的转化**：当发生**系统调用**(System call)时，模式会切换到内核态；当系统调用返回时，模式会重置为用户态。

     > 内核态->用户态：由一条特权指令——修改PSW的标志位为用户态。
     > 用户态->内核态：由**中断**引发，硬件自动完成变态过程。触发**中断信号**意味着操作系统将强行夺回CPU的使用权。**System call**是一种软件中断。
     >
2. **用户态**(User Mode)：

   * **模式位**：1
   * 用户程序在CPU上执行
   * CPU调度通常会导致CPU在用户模式和内核模式之间切换

## 内核程序与用户程序

**内核程序**(Kernel)：

* 定义：计算机上始终运行的那个程序。
* 操作系统= 内核+系统程序
* 内核提供文件系统、CPU调度、内存管理以及其他操作系统功能。

**用户程序**/**应用程序**(Application Programs)

* 定义：使用系统资源来解决用户的计算问题。
* 除了内核和系统程序之外的**所有程序**都属于应用程序。
* 用户程序在用户态下运行。

## 特权指令与非特权指令

**特权指令**(Privileged Instruction)：

* 特权指令是指那些可能造成危害的机器指令。
* 特权指令只能在**内核模式**下运行。
* 如果处于**用户态**的用户程序试图执行**特权指令**，硬件不会执行这些指令，而是会将其视为**非法操作**。此时系统会生成一个**陷阱**(trap)，并将CPU控制权传递给操作系统来处理这个错误。

**非特权指令**(Non-privileged Instruction)：

* 非特权指令可以在用户模式下安全的执行。

![1761220643979](image/第一章--操作系统概述_20251023_153138/1761220643979.webp)

# 中断和异常

![1761266475955](image/第一章--操作系统概述_20251023_153138/1761266475955.webp)

## 中断

CPU上运行着两种程序：操作系统**内核程序**和**应用程序**。

在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序，而**中断**就是让操作系统内核夺回CPU使用权的唯一途径。

类型：

* 内中断(异常)：与当前执行的指令有关，中断信号来自于CPU内部。
  * **故障**(fault)：可能被内核修复的错误。
    * 缺页故障
  * **终止**(abort)：内核无法修复的错误。结束程序。
    * 应用程序执行特权指令
    * 执行除法指令时发现除数为0
  * **陷阱**(trap)：程序故意引发。
    * 应用程序想进行系统调用，执行**陷入指令**(trap)，该指令会引发一个内部中断信号。
* 外中断(中断)：与当前执行的指令无关，中断信号来自于CPU外部。(键盘输入)
  * 时钟中断：时钟部件每隔一个时间片。会给CPU发送一个时钟中断信号。
  * I/O中断：由输入/输出设备发来的中断信号

## 中断机制的基本原理

不同的中断信号，需要不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询"中断向量表"，以此来找到相应的中断处理程序在内存中存放的位置。

![1761267852289](image/第一章--操作系统概述_20251023_153138/1761267852289.webp)

![1761267987095](image/第一章--操作系统概述_20251023_153138/1761267987095.webp)

# 系统调用

![1761268108589](image/第一章--操作系统概述_20251023_153138/1761268108589.webp)

操作系统作为用户和计算机硬件之间的接口，需要向上同一提供一些简单易用的服务。主要包括命令接口和程序接口。其中**程序接口**由一组**系统调用**组成。

**系统接口**：是操作系统给应用程序使用的接口，是一种可供应用程序调用的特殊函数。应用程序可以通过**系统调用**来请求获得操作系统内核的服务。

## 系统调用与库函数的区别

| 层级         | 描述                                                                                                             |
| ------------ | ---------------------------------------------------------------------------------------------------------------- |
| 普通应用程序 | 可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及                                           |
| 编程语言     | **向上**提供库函数。时常会将**系统调用封装成库函数**，以隐藏系统调用的一些细节，使程序员编程更加方便 |
| 操作系统     | **向上**提供系统调用，使得上层程序能请求内核的服务                                                         |
| 裸机         | ——                                                                                                             |

## 为什么系统调用是必须的

对于硬件资源，有些资源我们可以共享访问，而有些资源我们必须互斥访问。如果不对资源的调用统一进行管理，而让每个应用程序直接操控硬件资源，就引发混乱。

由操作系统内核对共享资源进行统一管理，并向上提供系统调用，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求，等待内核分配资源。

## 什么功能要用到系统调用

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核进行统一掌管，因此凡是**与共享资源有关的操作**(如存储分配，I/O操作，文件管理等)，都**必须通过系统调用**的方式向操作系统内核**提出服务请求**，又操作系统内核**代为完成**。保证系统的稳定性和安全性。

系统调用的分类：

* 设备管理：完成设备的 请求/释放/请求 等功能
* 文件管理：完成文件的 读写/创建/删除 等功能
* 进程管理：完成进程的 创建/撤销/阻塞/唤醒 等功能
* 进程通信：完成进程之间的 消息传递/信号传递 等功能
* 内存管理：完成内存的 分配/回收 等功能

## 系统调用的过程

1. 用户模式：系统调用发起请求
   * 实际编程中，程序通过调用库函数来访问系统调用，而不是直接使用系统调用。
2. 传递参数：
   * 系统调用通常需要传递比仅标识调用本身更多的信息。
   * 向操作系统传递参数的方法：
     * 寄存器传递
     * 内存块传递：将参数存储在内存中的一个块或表格中，然后将该地址作为参数传递到寄存器中。(Linux中使用)
     * 堆栈传递
3. 模式切换和执行
   * 系统调用触发一个陷阱/异常
   * 模式切换：CPU从用户模式切换到内核模式
   * 一旦进入内核模式，操作系统内核就开始执行用户程序请求的服务。
4. 完成与返回
   * 系统调用返回时，CPU模式切换到用户模式。
   * 调度器(scheduler)选择下一个运行的线程/进程，并将控制权交给分派器(dispatcher)，分派器负责将CPU控制权交给该进程/线程，并跳转到用户程序正确的位置继续执行。

# 操作系统的体系结构

## 操作系统的内核

![1761272963347](image/第一章--操作系统概述_20251023_153138/1761272963347.webp)

> 原语：一种特殊的程序，具有原子性，不可被中断。

内核：操作系统中最基本，最核心的部分。

内核程序：实现操作系统内核功能的那些程序就是内核程序。

### 大内核与微内核

![1761273511170](image/第一章--操作系统概述_20251023_153138/1761273511170.webp)

#### 宏内核(大内核)

所有的系统功能都放在内核里。

优点：

* 性能高，内核内部各种功能都可以直接相互调用。

缺点：

* 内核庞大功能复杂。难以维护。
* 大内核中某个功能出错，就可能导致整个系统崩溃。

#### 微内核

只把中断、原语、进程通信等核心功能放入内核、进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态。

优点：

* 内核小，功能少，易于维护，可靠性高。
* 内核外的某个功能模块出错不会导致整个系统崩溃。

缺点：

* 性能低，需要频繁切换用户态/核心态
* 用户状态下的各个模块不能直接相互调用，必须依靠消息传递。

## 分层结构

![1761274016255](image/第一章--操作系统概述_20251023_153138/1761274016255.webp)

操作系统内核分为多层，每层可单向调用**更低一层**模块的接口。

**优点**：

* 便于调试和验证，自底层向上逐层调试验证。
* 易于扩充和维护。

**缺点**：

* 仅可调用相邻低层，难以合理划分各层边界。
* 效率低，不可跨层调用。

## 模块化

将内核划分为多个模块，各个模块之间相互协作。内核 = 主模块 + 可加载内核模块

* 主模块：只负责核心功能，进程管理、内存管理。
* 可加载内核模块：可以动态加载新模块到内核，而无需编译整个内核。

优点：

* 逻辑清晰，易于维护，确定模块间的接口后，就可以多模块并行开发。
* 支持动态加载新的内核模块，增强OS适应性。
* 任何模块可以直接调用其他模块，无需采用消息传递，效率高。

缺点：

* 模块间的接口定义未必合理实用。
* 模块间相互依赖，更难测试和验证。

## 外核

内核负责进程调度、进程通信等功能，外核负责为用户进程分配**未经抽象的硬件资源**，且由外核负责**保证资源使用安全**。

优点：

* 外核可以直接给用户进程分配不虚拟、不抽象的硬件资源，使用户进程可以更灵活的使用硬件资源。
* 减少了虚拟硬件资源的映射层，提升效率。

缺点：

* 降低了系统一致性
* 使系统变得更复杂。

# 操作系统的引导

![1761276135871](image/第一章--操作系统概述_20251023_153138/1761276135871.webp)

1. CPU从一个特定的主存地址开始，取指令，执行**ROM中的引导程序**。
2. 将磁盘的第一块——主引导记录读入内存，执行**磁盘引导程序**，扫描分区表。
3. 从活动分区(主分区，即安装了操作系统的分区)读入**分区引导记录**，执行其中的程序。
4. 从根目录下找到完整的**操作系统初始化程序**(即启动管理器)并执行，完成开机的一系列动作。

# 虚拟机

虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine, VM)，每个虚拟机都可以独立运行一个操作系统。

同义术语：虚拟机管理程序/虚拟机监控程序(Virtual Machine Monitor/Hypervisor)。

![1761277036576](image/第一章--操作系统概述_20251023_153138/1761277036576.webp)

| 分类               | 第一类VMM                                                 | 第二类VMM                                                             |
| ------------------ | --------------------------------------------------------- | --------------------------------------------------------------------- |
| 对物理资源的控制权 | 直接运行在物理硬件上，拥有对物理资源的控制权              | 运行在Host OS之上，物理资源的控制权由Host OS负责                      |
| 资源分配方式       | 直接支持Guest OS时，VMM将虚拟主机的硬件资源分配给Guest OS | Guest OS的资源是由宿主操作系统分配的，VMM通过宿主操作系统间接分配资源 |
| 性能               | 性能更高                                                  | 性能较低，容易与Host OS行为“冲突”                                   |
| 可支持的虚拟机数量 | 更多，不受限于Host OS的支持能力                           | 更少，受限于宿主操作系统的支持能力                                    |
| 虚拟机的安全性     | 更高，VMM直接控制硬件资源，Guest OS之间相互隔离           | 较低，Guest OS之间通过宿主操作系统进行资源共享，容易受到攻击          |
| 运行模式           | VMM运行在最高权限级别（Ring 0），可直接访问硬件资源       | VMM运行在用户态，不能直接访问硬件资源，需通过Host OS进行访问          |
