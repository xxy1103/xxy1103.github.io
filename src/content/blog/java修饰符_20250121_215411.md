---
title: java修饰符
date: 2025-01-21 21:54:11
categories: 笔记
tags: java
---
# 每日一言

I don't want to be anyone's burden. I don't want you to be my dad if it's going to hurt you. (thinking about Kazuma) -- Sohma Kyo
from Fruits Basket

<!-- more -->

# Java中的包

**包 (package)** 是一种用于组织和管理 Java 类和接口的机制。包的主要作用是为 Java 代码提供命名空间。

包的作用：

1. **命名空间管理** ：避免类名冲突。
2. **访问控制** ：可以控制类和接口的访问级别。
3. **代码组织** ：使代码结构更加清晰和有条理。

## 声明一个包

在Java中，通过 `package`关键字来声明一个类所属的包。**包声明语句必须出现在java源文件的第一行。**

```java
package com.example.ui;  // 声明该类属于 com.example.ui 包

public class Button {
    // ...
}

```

### 包命名约定

通常，Java 包名使用小写字母，并且使用反向域名的方式来命名，例如：

* `com.example.myapp`
* `org.apache.commons`
* `net.sf.hibernate`

这种命名约定有助于确保包名的唯一性，避免与其他开发者创建的包发生冲突。

## 引入一个包

引入包我们通常使用 `import`关键字，可以选择引入包中的某个类，也可以选择引入包中的全部类。

```java
import 包名.类名; // 导入一个特定的类
import 包名.*;  // 导入整个包中的所有类
```

假如我们只需导入 `com.example.ui` 包中的 `Button`类：

```java
import com.example.ui.Button
```

假如我们需要引入 `com.example.ui`中的所有类：

```java
import com.example.ui.*
```

用*代替类名表示所有类。

# 访问修饰符

访问修饰符可以调整类，变量，方法和构造方法的访问权限。Java中有四种不同的访问权限：

* **default(默认)**：在同一包内可见，不使用任何修饰符。
  * 使用范围：类，接口，变量，方法
* **private**：在同一类内可见。
  * 使用范围：不能修饰外部类。
* **public**：对所有类可见。
  * 使用范围：类，接口，变量，方法
* **protected**：对同一包内的类和**不同包**的子类可见。
  * 使用范围：不能修饰外部类

注释：上述所指的**子类**，是指由父类继承而来的子类。

针对protected，一个直观的例子：

```java
// 文件名：ParentClass.java (在 com.example.parentpackage 包中)
package com.example.parentpackage;

public class ParentClass {
    protected int myVariable; // 受保护的变量

    protected void myMethod() { // 受保护的方法
        // ...
    }
}

// 文件名：ChildClass.java (在 com.example.childpackage 包中)
package com.example.childpackage;

import com.example.parentpackage.ParentClass;

public class ChildClass extends ParentClass {
    public void test() {
        this.myVariable = 20;  // 可以访问，因为是子类
        this.myMethod();       // 可以访问，因为是子类
    }
}

// 文件名：AnotherClass.java (在 com.example.childpackage 包中，非子类)
 package com.example.childpackage;

 import com.example.parentpackage.ParentClass;

public class AnotherClass {
     public void test(){
          ParentClass obj = new ParentClass();
          // obj.myVariable = 10; // 错误！无法访问，因为不同包且非子类
          // obj.myMethod();     // 错误！无法访问，因为不同包且非子类
     }
}

// 文件名：OtherClass.java (在 com.example.parentpackage 包中)
package com.example.parentpackage;

public class OtherClass {
    public void test() {
        ParentClass obj = new ParentClass();
        obj.myVariable = 10;  // 可以访问，因为在同一个包中
        obj.myMethod();       // 可以访问，因为在同一个包中
    }
}

```

**总结**

| 访问修饰符    | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| ------------- | -------- | -------- | ------------ | -------------- |
| `public`    | ✓       | ✓       | ✓           | ✓             |
| `protected` | ✓       | ✓       | ✓           | ✕             |
| `default`   | ✓       | ✓       | ✕           | ✕             |
| `private`   | ✓       | ✕       | ✕           | ✕             |

### 访问控制和继承

请注意以下方法继承的规则：

* 父类中声明为 public 的方法在子类中也必须为 public。
* 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
* 父类中声明为 private 的方法，不能够被子类继承。

# 非访问修饰符

## static静态修饰符

static 关键字用于修饰**变量**或**方法**

* **静态变量：**
  static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。
* **静态方法：**
  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

## final修饰符

final修饰符可以用来修饰**类**、**变量**、**方法**

### final类

final 类不能被继承，没有类能够继承 final 类的任何特性。

```java
public final class Test {
   // 类体
}
```

### final变量

final修饰符声明的变量必须要显式的初始化，并且该变量在初始化后无法被修改，其效果类似于c语言中的const关键字。

final修饰符常于static修饰符一起使用来创建类常量。

```java
public class Test{
  final int value = 10;
  // 下面是声明常量的实例
  public static final int BOXWIDTH = 6;
  static final String TITLE = "Manager";
 
  public void changeValue(){
     value = 12; //将输出一个错误
  }
}
```

### final方法

final修饰符修饰方法的主要限制在于：

防止final修饰的方法在被子类继承时**重写**。

```java
public class Test{
    public final void changeName(){
       // 方法体
    }
}
```

## abstract修饰符

abstract修饰符可以用来修饰**类**、**方法**

### abstract方法

abstract方法是一种只有声明，没有任何定义的方法，abstract方法的具体实现应该由子类提供，其声明方式如下：

```java
public abstract void goFast(); //抽象方法
```

abstract方法不能与final，static修饰符同时使用。

### abstract类

只要含有至少一个abstract方法，就一定要声明为abstract类，当然没有abstract方法时，也可以声明为abstract类。

abstract类的不能用来实例化对象，它唯一的目的就是为了将来对该类进行扩充。所以abstract类也不能被final修饰。

示例：

```java
abstract class Caravan{
   private double price;
   private String model;
   private String year;
   public abstract void goFast(); //抽象方法
   public abstract void changeColor();
}
```

任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

## synchronized 修饰符

synchronized修饰符可以用来修饰**方法。**

```java
public synchronized void showDetails(){
.......
}
```

synchronized 关键字声明的方法**同一时间**只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

## volatile 修饰符

volatile修饰符用于修饰**变量**

volatile修饰的变量在不同线程的运行中将保持一致性，即在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

```java
public class MyRunnable implements Runnable
{
    private volatile boolean active;
    public void run()
    {
        active = true;
        while (active) // 第一行
        {
            // 代码
        }
    }
    public void stop()
    {
        active = false; // 第二行
    }
}
```

通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 ***第一行*** 中缓冲区的 active 值被使用，那么在 ***第二行*** 的 active 值为 false 时循环不会停止。

但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。
