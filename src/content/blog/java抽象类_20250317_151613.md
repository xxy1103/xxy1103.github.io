---
title: java抽象类
date: 2025-03-17 15:16:13
categories: 笔记
tags: java
---
# 每日一言

So, who should we hold responsible? Compensation. Punishment. If you didn't want any problems you shouldn't have taken risks. -- Watashi
from Humanity Has Declined

<!-- more -->

# 抽象类

抽象类是用关键字 `abstract` 修饰的类。

我们创建一个基本的抽象类如下：

```java
public abstract class Animal{
    //成员变量
    String name;
    //构造方法
    public Animal(String name){
        this.name = name;
    }
    //成员方法
    public void sleep(){
        System.out.println(name + " is sleeping");
    }
    //抽象方法
    public abstract void eat();
}
```

`abstract`类具有以下特征：

1. 不能直接实例化
2. **可以**包含抽象方法
3. 其余特性与普通的类一致

所以我们我们仅仅只需在两种情况下声明一个 `abstract`类：

* 我们不希望编写的类被实例化，希望它仅仅作为基类，被子类继承
* 对于类的某些方法还不确定实现方法，需要声明一个抽象方法

虽然 `abstract` 类无法被实例化，但这并不表明我们无法声明一个抽象类。就像在多态中讲的那样，我们依然可以创建子类作为示例，但是用他的父类(抽象类)来声明实例。

```java
abstract class Animal {  
    static String name = "动物";  //静态变量
    abstract void eat();  
  }
  
class Cat extends Animal { 
    @Override 
    public void eat() {  
        System.out.println("吃鱼");  
    }  
  }  

public class Test {
    public static void main(String[] args) {
      System.out.println(Animal.name);  //抽象类也可以访问静态变量、静态方法
      Animal a = new Cat();  //抽象类可以引用子类对象
      a.eat();  
      Cat c = (Cat)a;  
      c.eat();   
    }
 }  


```

# 抽象方法

抽象方法是使用 `abstract`关键字修饰的成员方法。声明方式如下：

```java
<访问修饰符> abstract <返回值类型> <方法名>(参数列表);
//示例
public abstract double calculateArea();
abstract void eat(); 
```

声明限制：抽象方法只能在下面两个地方进行声明

* 抽象类中
* 接口中
* 构造方法、类方法(static修饰的方法)无法被 `abstract`修饰

继承抽象类的子类必须实现(**重写**)所有的抽象方法，除非子类也是抽象类。

对于父类抽象方法的重写也算是一种重写，所以需要遵守重写的相关规则：

* **参数列表**与被重写方法的参数列表必须完全相同
* **返回类型**与被重写方法的返回类型可以不同，但必须是父类返回值的派生类
* **访问权限**不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
* 子类和父类在同一个包中，那么子类可以重写父类的所有方法，除了声明为private和final的方法
* 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法
