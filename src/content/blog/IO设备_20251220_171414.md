---
title: IO设备
date: 2025-12-20 17:14:14
categories: 笔记
tags: ['操作系统']
---
无聊一点，接受迷失...

<!-- more -->

# I/O设备的基本概念和分类

"I/O"就是"输入/输出"。

I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。

* Write操作：向外部设备写出数据
* Read操作：从外部设备读入数据

I/O设备的分类：

* 按使用特性分：
  * 人机交互类外设
  * 存储设备
  * 网络通信设备
* 按传输速率分：
  * 低速设备
  * 中速设备
  * 高速设备
* 按信息交换的单位分类：
  * 块设备：磁盘等，传输速度快，可以寻址。
  * 字符设备：键鼠，传输慢，不可寻址，常采用中断驱动方式。

# I/O控制器(电子部件)

CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的中介，用于实现CPU对设备的控制。

I/O控制器的功能：

* 接收和识别CPU发出的命令
  * 控制寄存器：用于存放命令和参数
* 向CPU报告设备的状态
  * 状态寄存器：记录I/O设备当前的状态
* 数据交换
  * 数据寄存器：用于暂存要输入输出的数据。
* 地址识别
  * 区分设备控制器中的各个寄存器。I/O控制器通过CPU给出的地址判断CPU要读写的寄存器。

## I/O控制器的组成

![1766223747856](image/IO设备_20251220_171414/1766223747856.webp)

* CPU与控制器的接口

  * 用于实现CPU与控制器之间的通信。CPU通过控制线发出命令；通过地址线指明要操作的设备；通过数据线来取出(输入)数据，或放入(输出)数据。
* I/O逻辑

  * 负责接收和识别CPU的各种命令(如地址译码)，并负责对设备发出命令。
* 控制器与设备的接口(多个，通过地址区分)。

  * 用于实现控制器与设备之间的通信。

> * 一个I/O控制器可能会对应多个设备
> * 数据寄存器、控制寄存器、状态寄存器可能也有多个，且这些寄存器都要有相应的地址才能方便CPU操作。有的计算机会让这些寄存器**占用内存地址的一部分**，称为**内存映像I/O**，另一些计算机则采用**I/O专用地址**，即**寄存器独立编址**。

## 内存映像I/O VS 寄存器独立编址

![1766224078810](image/IO设备_20251220_171414/1766224078810.webp)

内存映像I/O优点：

* 简化了指令。可以采用对内存进行操作的指令来对控制器进行操作。

寄存器独立编址缺点：

* 需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器地址，还要指明控制器的编号。

# I/O控制方式

需要注意的问题：

* 完成一次读/写操作的流程。
* CPU干预的频率
* 数据传送的单位
* 数据的流向
* 主要缺点和主要优点

## 程序直接控制方式

1. CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1(未就绪)。
2. **CPU轮询检查控制器的状态**。
3. 输入设备准备好数据后将数据传给控制器，并报告自身的状态。
4. 控制器将输入的数据放到数据寄存器中，并将状态改为0(已就绪)。
5. CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器中，再把CPU寄存器中的内容放入内存。
6. 若还要继续读入数据，则CPU还要继续发出读指令。

![1766230821958](image/IO设备_20251220_171414/1766230821958.webp)

CPU干预的频率：

* 很频繁，I/O操作开始前、完成之后需要CPU介入，并且在等待I/O完成时需要CPU不断的轮询检查。

数据传输的单位：

* 每次读写一个**字**

数据的流向：

* 读操作：I/O设备->CPU->内存
* 写操作：内存->CPU->I/O设备
* 每个字的读/写都需要CPU的帮助。

主要的缺点和主要优点：

* 优点：实现简单。在读/写指令后，加上实现循环检查的一系列指令即可。
* 缺点：CPU和I/O只能串行的工作，CPU需要一直轮询检查，长期处于忙等待状态。

## 中断驱动方式

引入**中断机制**。

1. 由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。
2. 当I/O完成后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。
3. 处理中断的过程中，CPU从I/O控制器读取1个字的数据传送到CPU寄存器，再写入主存。
4. 接着CPU恢复等待I/O的进程的运行环境，然后继续执行。(可选)

CPU的干预频率：

* 每次I/O操作开始前、完成之后需要CPU介入。

数据传输的单位：

* 一个字

数据的流向：

* 读：I/O设备->CPU->内存
* 写：内存->CPU->I/O设备

主要的缺点和主要优点：

* 优点：与"程序直接控制方式"相比，在"中断驱动方式"中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停的轮询。CPU和I/O设备可以并行工作。
* 缺点：每个字在I/O设备与内存直接的传输，都需要经过CPU。**而频繁的中断处理会消耗较多的CPU时间**。

## DMA

DMA(Direct Memory Access) 直接存储器存储。主要用于块设备的(I/O控制)。

1. 数据的传送单位是"块"。不再是一个字、一个字的传送。
2. 数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为快递小哥。
3. 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。

![1766232500304](image/IO设备_20251220_171414/1766232500304.webp)

### DMA控制器

![1766232656224](image/IO设备_20251220_171414/1766232656224.webp)

寄存器：

* DR(Data Register 数据寄存器)：暂存从设备到内存，或从内存到设备的数据。
* MAR(Memory Address Register，内存地址寄存器)：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置。
* DC(Data Counter 数据寄存器)：表示剩余要读/写的字节数。
* CR(Command Register 命令/状态寄存器)：用于存放CPU发来的 I/O命令，或设备的状态信息。

CPU干预频率：

* 仅在传送一个或多个块的开始和结束时，才需要CPU干预

数据传输的单位：

* 每次读写一个或多个块(只能是连续的块，并且存入内存后需要连续的)。

数据的流向：

* 读：I/O设备->内存
* 写：内存->I/O设备

主要缺点和主要优点：

* 优点：
  * 数据传输以块为单位，CPU介入频率进一步降低。
  * 不再经过CPU，数据传输效率进一步增加。
  * CPU和I/O设备的并行性得到提升。
* 缺点：CPU每次发出一条I/O指令，只能读写一个或多个**连续的数据块**。

## 通道控制方式

通道：一种硬件，可以识别并执行一系列通道指令。

1. CPU向通道发出I/O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备，之后CPU就切换到其他进程执行了
2. 通道执行内存中的通道程序。其中指明了要读入/写出多少数据，读/写的数据应放在内存的什么位置等信息。
3. 通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理

CPU干预频率：

* 极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。

数据传输的单位：

* 每次读写一组数据块

数据的流向：

* 读：I/O设备->内存
* 写：内存->I/O设备

主要的优点及缺点：

* 优点：CPU、通道、I/O设备可并行工作，资源利用率很高。
* 缺点：实现复杂，需要专门的通道硬件支持。

# I/O软件层次结构

* 用户层软件
* 操作系统内核部分：
  * 设备独立性软件
  * 设备驱动程序
  * 中断处理程序
* 硬件

> 每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务。

## 用户层软件

用户层软件实现了**与用户交互的接口**，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。

例子：`printf("hello, world!");`

## 设备独立性软件

又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。

功能：

* 向上层提供统一的调用接口(如read/write系统调用)。
* 设备的保护。

  * 不同用户对于各个设备的访问权限也不一样。
* 差错处理
* 设备的分配与回收
* 数据缓冲区管理

  * 屏蔽设备之间数据交换大小和传输速度差异。
* 建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序。

  * 通过逻辑设备表(LUT, Logical Unit Table)来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。

    ![1766314830186](image/IO设备_20251220_171414/1766314830186.webp)
  * 方式一：整个系统用一张逻辑设备表，所有用户不能使用相同的逻辑设备名。
  * 方式二：为每个用户设置一个逻辑设备表(适合多用户)。

## 设备驱动程序

主要负责对硬件设备的具体控制，将**上层发出的一系列命令**(如read/write)**转化为特定设备能听懂的一系列操作**。包括设置设备寄存器，检查设备状态等。

不同的I/O设备有不同的硬件特性，具体细节只有设备的厂家才知道。因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。

## 中断处理程序

当硬件设备任务完成时，I/O控制器会发送一个**中断信号**，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：

![1766315460049](image/IO设备_20251220_171414/1766315460049.webp)

## 硬件

实际执行I/O操作马，有机械部件、电子部件组成。

# 输入输出管理

## 输入/输出应用程序接口

用户层的应用程序无法用一个统一的系统调用接口来完成所有类型设备的I/O。

分类：

* 字符设备接口
  * get/put系统调用：向字符设备读/写一个字符。
* 块设备接口
  * read/write系统调用：向块设备的读写指针位置读/写多个字符。
  * seek系统调用：修改读写指针的位置。
* 网络设备接口(网络套接字接口)
  * socket系统调用：创建一个网络套接字，需指明网络协议
  * bind：将套接字绑定到某个本地端口
  * connect：将套接字连接到远程地址
  * read/write：从套接字读写数据

### 阻塞或非阻塞I/O

阻塞I/O：应用程序发出I/O系统调用，进程需转为阻塞态等待。

* 从键盘读一个字符get

非阻塞I/O：应用程序发出I/O系统调用，系统调用可迅速返回，进行无需等待阻塞。

* 往磁盘写入数据write

## 设备驱动程序接口

操作系统规定好设备驱动程序的标准接口，各厂商必须按要求开发设备的驱动程序。

# I/O核心子系统

![1766364513184](image/IO设备_20251220_171414/1766364513184.webp)

I/O核心子系统包括：

* 用户层软件
  * 假脱机技术(SPOOLing技术)
* 设备独立性软件
  * I/O调度、设备保护、设备分配与回收、缓冲区管理。
* 设备驱动程序
* 中断处理程序

I/O调度

用某种算法确定一个好的顺序来处理各个I/O请求

* 先来先服务
* 优先级算法
* 短作业优先

设备保护

操作系统需要实现文件保护功能，不同用户对各个文件有不同的访问权限(如：只读、读写等)。

在UNIX系统中，设备被看作是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现设备保护的功能。

## 假脱机技术(SPOOLing)

### 脱机技术

批处理阶段引入了脱机输入/输出技术(用磁带完成)：

![1766365309830](image/IO设备_20251220_171414/1766365309830.webp)

> 脱机：脱离主机的控制进行的输入/输出操作。

引入脱机技术后，缓解了CPU与慢速I/O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。

### 假脱机技术

假脱机技术，又称SPOOLing技术，是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：

![1766365542856](image/IO设备_20251220_171414/1766365542856.webp)

* 输入井：模拟脱机输入时的磁带，用于收容I/O设备输入的数据。
* 输出井：模拟脱机输出时的磁带，用于收容用户进程输出的数据。
* 输入进程：模拟脱机输入时的外围控制机。
* 输出进程：模拟脱机输出时的外围控制机。
* 输入缓冲区：用于暂存从输入设备输入的数据，之后再转存到输入井中。
* 输出缓冲区：用于暂存从输出井送来的数据，之后再传送到输出设备上。

#### 共享打印机原理分析

独占式设备——只允许各个进程串行使用设备

共享设备——允许多个进程同时使用(微观上可能是交替使用)

![1766366163872](image/IO设备_20251220_171414/1766366163872.webp)

当多个用户进程提出输出打印请求时，系统会答应它们的请求，但是并不真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：

1. 在磁盘输出井中为进程申请一个空闲缓冲区(缓冲区在磁盘上)，并将要打印的数据送入其中；
2. 为用户进程申请一张空白打印请求表，并将用户的打印请求填入表中(用来说明用户的打印数据存放位置等信息)，再将该表挂到假脱机文件队列上。

当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。

SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。

# 设备的分配与回收

## 设备分配时应考虑的因素

* 设备的固有属性
* 设备分配算法
* 设备分配中的安全性

### 设备的固有属性

* 独占设备
  * 一个时段只能分配给一个进程
* 共享设备
  * 可同时分配给多个进程使用
* 虚拟设备
  * 采用SPOOLing技术把独占设备改造为虚拟共享设备

### 设备的分配算法

* 先来先服务
* 优先级高者优先
* 短服务优先
* ...

### 设备分配中的安全性

* 安全分配方式
  * 为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。
  * 优点：破坏了请求保持条件，不会死锁
  * 缺点：进程利用率低，只能串行工作
* 不安全分配方式
  * 进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程 阻塞。
  * 优点：进程的计算任务和I/O任务可以并行处理，使得进程迅速推进
  * 缺点：有可能发送死锁

## 静态分配和动态分配

静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源

动态分配：进程运行过程中动态的申请资源

## 设备分配中的数据结构

![1767320465305](image/IO设备_20251220_171414/1767320465305.webp)

一个通道可以控制多个设备控制器，每个控制器可控制多个设备。

### 设备控制表(DCT)

系统为每个设备配置一张DCT，用于记录设备情况：

![1767320754806](image/IO设备_20251220_171414/1767320754806.webp)

### 控制器控制表(COCT)

每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进程操作和管理。

![1767320856564](image/IO设备_20251220_171414/1767320856564.webp)

### 通道控制表(CHCT)

每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。

![1767320919452](image/IO设备_20251220_171414/1767320919452.webp)

### 系统设备表(SDT)

记录了系统中全部设备的情况，每个设备对应一个表目。

![1767321010353](image/IO设备_20251220_171414/1767321010353.webp)

## 设备分配的具体步骤

1. 根据进程请求的**物理设备名**查找SDT
2. 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。
3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
4. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。

缺点：

* 用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程
* 若换一个物理设备，则程序无法运行
* 若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待。

改进：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。

改进后：

1. 进程请求逻辑设备名查找SDT
2. 查找SDT，找到用户进程**指定类型的**、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表(LUT)中新增一个表项。
3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
4. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。

### 逻辑设备表

![1767322707228](image/IO设备_20251220_171414/1767322707228.webp)

逻辑设备表(LUT)建立了**逻辑设备名与物理设备名之间的映射关系**。

# 缓冲区管理

## 缓冲区

* 缓和CPU与I/O设备之间速度不匹配的矛盾
* **减少对CPU的中断频率**，放宽对CPU中断相应时间的限制
* 解决数据粒度不匹配的问题
* 提高CPU与I/O设备之间的并行性

## 缓冲区管理策略

### 单缓冲

假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为分配一个缓冲区(一般为一个块)

策略：

* 当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；
* 当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后，才能从缓冲区把数据传出。

![1767323591578](image/IO设备_20251220_171414/1767323591578.webp)

> 小技巧：假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需的时间。

结论：

![1767324156258](image/IO设备_20251220_171414/1767324156258.webp)

Max(C, T) +M

### 双缓存策略

假设某用户进程请求某种块设备读入若干块。若采用双缓存的策略，操作系统会在主存中为其分配两个缓冲区。(一般一个缓冲区为一个块)

双缓冲题目中，假设初始状态为：工作区空，一个缓冲区满，另一个缓冲区空。

 T >C+M![1767324060576](image/IO设备_20251220_171414/1767324060576.webp)

T < C+M

![1767324106749](image/IO设备_20251220_171414/1767324106749.webp)

结论：Max(T, C+M)

### 单/双缓冲在通信的区别

两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。

![1767335185169](image/IO设备_20251220_171414/1767335185169.webp)

若两个相互通信的机器只设置单缓冲区，在任意时刻只能实现数据的单向传输。

![1767335284427](image/IO设备_20251220_171414/1767335284427.webp)

双缓冲区则可以实现全双工的传输。

### 循环缓冲区

将多个大小相等的缓冲区链接成一个循环队列。

![1767335392034](image/IO设备_20251220_171414/1767335392034.webp)

### 缓冲池

**缓冲池**由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：

* 空缓冲队列
* 转满输入数据的缓冲队列(输入队列)
* 装满输出数据的缓冲队列(输出队列)。

![1767335674150](image/IO设备_20251220_171414/1767335674150.webp)

另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：

* 用于收容输入数据的工作缓冲区(hin)
* 用于提取输入数据的工作缓冲区(sin)
* 用于收容输出数据的工作缓冲区(hout)
* 用于提取输出数据的工作缓冲区(sout)

![1767335839108](image/IO设备_20251220_171414/1767335839108.webp)

1. 输入进程请求输入数据：
   * 空缓冲区队列取出一块放入hin
   * 收容输入把数据写入内存块
   * 将写满的内存块挂入输入队列的队尾
2. 计算进程想要取得一块输入数据
   * 从输入队列队头取出一个写满数据的内存块放入sin
   * 数据被输入到用户进程
   * 将取出数据的空缓冲区放入空缓冲区队列的队尾
3. 计算进程将准备好的数据冲入缓冲区
   * 从空缓冲区的队头取出一块放入hout
   * 用户进程写入数据
   * 将写满数据的缓冲区放入输出队列的队尾
4. 输出进程请求输出数据
   * 从输出队列的对头取出一个缓冲区放入sout
   * 将缓冲区中的数据提取输出
   * 将空缓冲区放入空缓冲区队列的队尾

# 磁盘

## 磁盘、磁道、扇区

![1767336613050](image/IO设备_20251220_171414/1767336613050.webp)

* 磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。
* 磁道：磁盘的盘面被划分为一个个磁道。这样的一个圈就是一个磁道。
* 扇区：一个磁道又被划分成一个个扇区，每个扇区就是一个磁盘块。**各个扇区存放的数据量相同**。

> 磁道最内侧的面积最小，所以最内侧的扇区数据密度最大。

## 如何在磁盘中读/写数据

需要把磁头移动到想要读/写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。

![1767336973885](image/IO设备_20251220_171414/1767336973885.webp)

## 盘面、柱面

柱面：所有盘面中相对位置相同的磁道组成柱面。

![1767337059798](image/IO设备_20251220_171414/1767337059798.webp)

### 磁盘的物理地址

可用(柱面号、盘面号、扇区号)来定位任意一个磁盘块。

在文件的物理结构中，经常提到文件数据存放在外存中的几号块，这个块号就可以转化为(柱面号，盘面号，扇区号)的地址形式。

1. 根据柱面号移动磁臂，让磁头指向指定的柱面
2. 激活指定盘面对应的磁头
3. 磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。

## 磁盘调度算法

### 一次磁盘读/写操作需要的时间

寻找时间(寻道时间)$T_s$：在读/写数据前，将磁头移动到指定磁道所花的时间。

1. 启动磁头臂时间，假设耗时为s。
2. 移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。

寻道时间：$T_s = s + m*n$

延迟时间$T_R$：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位：转/秒， 转/分)，则

平均所需的延迟时间：$T_R =1/2r$

传输时间$T_t$：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。则：

传输时间$T_t = b/(rN)$

### FCFS 先来先服务算法

根据进程请求访问磁盘的先后顺序进行调度。

一个例子：

![1767338459860](image/IO设备_20251220_171414/1767338459860.webp)

优点：

* 公平
* 如果请求访问的磁道比较集中的话，算法性能还算过的去。

缺点：

* 如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间很长。

### SSTF 最短寻找时间最短

SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(贪心算法)

一个例子：

![1767338749736](image/IO设备_20251220_171414/1767338749736.webp)

优点：性能较好，平均寻道时间短

缺点：可能产生饥饿现象。

### SCAN 扫描算法

SCAN两条规则：

* 只有磁头移动到**最外侧**磁道的适合才能往最内侧移动
* 移动到**最内侧**磁道的时候才能往外侧移动

由于磁头移动的方式很像电梯，因此也叫电梯算法。

例子：

![1767339122524](image/IO设备_20251220_171414/1767339122524.webp)

优点：

* 性能较好，平均寻道时间较短
* 不会产生饥饿现象

缺点：

* 只有到达最边上的磁道才能改变磁头的移动方向，事实上，处理了184号磁道的访问请求之后就不再需要往右移动了。
* SCAN算法对于各个位置磁道的响应频率不平均
  * 例子：此时磁头正在向右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了

### LOOK调度算法

如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。

例子：
![1767339601934](image/IO设备_20251220_171414/1767339601934.webp)

优点：效率更好

### C-SCAN 循环扫描算法

规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。

![1767339731955](image/IO设备_20251220_171414/1767339731955.webp)

优点：比起SCAN来，对于各个位置磁道的响应频率很平均

缺点：

* 只有到达最边上的磁道才能改变磁头的移动方向，事实上，处理了184号磁道的访问请求之后就不再需要往右移动了。
* 比起SCAN算法，平均寻道时间更长。

### C-LOOK算法

C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。

* 如果磁头移动方向上已经没有磁道访问请求了，就可以立即让磁头返回。
* 磁头只需要返回到有磁道访问请求的位置即可。

例子：

![1767340122947](image/IO设备_20251220_171414/1767340122947.webp)

## 减少延迟时间的方法

磁头读取一块的内容后，**需要一小段时间的进行处理**，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的"延迟时间"。

### 交替编号

若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。

![1767341206859](image/IO设备_20251220_171414/1767341206859.webp)

### 错位命名

![1767341803951](image/IO设备_20251220_171414/1767341803951.webp)

让跨盘读取时，也可以连读读取。减少延迟时间。

## 磁盘管理

### 磁盘初始化

1. 低级格式化(物理格式化)，将磁盘的各个磁道划分为扇区。一个扇区通常可以分为头、数据区域、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码(如奇偶校验、CRC循环校验冗余码等)，校验码用于校验扇区中的数据是否发生错误。
2. 将磁盘分区，每个分区由若干个相邻的柱面组成
3. 逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构(如 位示图、空闲分区表)

### 引导块

计算机开机时需要进行一系列初始化工作，这些初始化工作是通过执行初始化程序(自举程序)完成的。

在计算机的主板ROM中装入很小的“自举装入程序”。

计算机开机时先运行**自举装入程序**，通过执行该程序就可以找到**引导块**，并将**完整的自举程序**读入内存，完成初始化。

完整的自举程序放在磁盘的启动块(即引导块/启动分区)上，启动块位于磁盘的固定位置。

拥有启动分区的磁盘称为启动磁盘或系统磁盘。

### 坏块管理

对于简单的磁盘，可以在逻辑格式化时(建立文件系统时)对整个磁盘进行坏块检查，标明哪些扇区是坏扇区。

比如：在FAT表上标明。(这种方式中，坏块对操作系统**不透明**)。

> 不透明：指操作系统知道坏块的存在

对于复杂的磁盘，磁盘控制器(磁盘内部的一个硬件部件)会维护一个坏块链表。

在磁盘出厂前进行低级格式化(物理格式化)时就将坏块连进行初始化。

同时会保留一些备用扇区，用于替换坏块。这种方案称为**扇区备用**。且这种处理方式中，**坏块对于操作系统透明**。

> 透明：指操作系统察觉不到坏块的存在

# 固态硬盘

> 硬盘一定要硬✍

![1767344083451](image/IO设备_20251220_171414/1767344083451.webp)
