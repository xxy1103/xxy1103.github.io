---
title: 	"CCF 202206-2 寻宝！大冒险！"
date: 2024-07-28 19:13:56
tags: "CCF"
---
暴力模拟，只能70分：
```
#include<iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
int n ,L,S;
vector<vector<int>> table(L+1);
vector<vector<int>> tree(n);
vector<vector<int>> mine(S+1);
int judge(int x,int y) {
    for(int i = x;i <=S+x;i++) {
        for(int j = y;j<=S+y;j++) {
            if(i>L || j>L || table[i][j] != mine [i-x][j-y]) {
                return 0;
            }
        }
    }
    return 1;
}

int main() {
    int res = 0;
    cin >> n>>L>>S;
    table.resize(L+1);
    for(int i = 0;i<L+1;i++) {
        table[i].resize(L+1);
        for(int j = 0;j<L+1;j++) {
            table[i][j] = 0;
        }
    }
    tree.resize(n);
    for(int i = 0;i<n;i++) {
        tree[i].resize(2);
    }
    mine.resize(S+1);
    for(int i = 0;i<S+1;i++) {
        mine[i].resize(S+1);
    }
    for(int i = 0;i<n;i++) {
        cin >>tree[i][0] >>tree[i][1];
        table[tree[i][0]][tree[i][1]] = 1;
    }
    for(int i = S;i >=0;i--) {
        for(int j = 0;j<S+1;j++) {
            cin>>mine[i][j];
        }
    }
    for(int i = 0;i<n;i++) {
        if(judge(tree[i][0],tree[i][1])) {
            res++;
        }
    }
    cout << res;
    return 0;
}
```

大地图过大，无法完全绘制出大地图。我们将小地图中的树的坐标，全部转化为一个与小地图（0，0）点的对应关系，我们将小地图与大地图中的点一一对应，若小地图中的树的坐标与大地图中某棵树为（0，0）点时的树的位置完全一样，则为一个。
```
#include<iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
int n ,L,S,num_s = 0;
vector<vector<int>> tree;
vector<vector<int>> mine1;
int judge(int x,int y,int num) {
    if(x+S > L || y+S > L)
        return 0;
    int j = 0;
    for(int i = 0;i<num_s;i++) {
        while( num+i+j <n && ((tree[num+i+j][1] > y+S)||(tree[num+i+j][1] < y)) ) { //注意既要考虑上也要考虑下
            j++;
        }
        if(num+i+j >=n)
            return  0;
        if(tree[num+i+j][0] != mine1[i][0]+x || tree[num+i+j][1] != mine1[i][1]+y)
            return 0;
    }
    while(num + num_s + j < n && tree[num + num_s+j][0] <= x+S) {
        if((tree[num + num_s+j][1] <= y+S ) && (tree[num + num_s+j][1] >= y))
            return 0;
        else
            j++;
    }
    return 1;
}
bool cmp(vector<int>x,vector<int>y) {
    if(x[0] == y[0])
        return x[1] <y[1];
    return x[0] < y[0];
}
int main() {
    int res = 0;
    cin >> n>>L>>S;
    tree.resize(n);
    for(int i = 0;i<n;i++) {
        tree[i].resize(2);
    }
    for(int i = 0;i<n;i++) {
        cin >>tree[i][0] >>tree[i][1];
    }
    for(int i = S;i >=0;i--) {
        for(int j = 0;j<S+1;j++) {
            int tmp;
            cin>>tmp;
            if(tmp == 1) {
                num_s ++;
                vector<int> t(2);
                t[0] = i;
                t[1] = j;
                mine1.push_back(t);
            }
        }
    }
    sort(mine1.begin(),mine1.end(),cmp);
    sort(tree.begin(),tree.end(),cmp);
    for(int i = 0;i<n;i++) {
        if(judge(tree[i][0],tree[i][1],i)) {
            res++;
        }
    }
    cout << res;
    return 0;
}
```