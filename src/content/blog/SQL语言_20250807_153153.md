---
title: SQL基础
date: 2025-08-07 15:31:53
categories: 笔记
tags: ['MySQL', '数据库']
---
编写函数毕竟是为了把较大的概念拆分为另一抽象层上的一系列步骤，函数中的语句应在同一抽象层上。——《Clean Code》

<!-- more -->

# SQL

### **SQL通用语法**

1. SQL语句可以单行或多行书写，以分号结尾。
2. SQL语句可以使用空格/缩进来增强语句的可读性。
3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。
4. 注释：
   * 单行注释：`--`注释内容或 `#`注释内容(MySQL特有)
   * 多行注释：`/* 注释内容 */`

### SQL分类

| 分类 | 全称                       | 说明                                                     |
| ---- | -------------------------- | -------------------------------------------------------- |
| DDL  | Data Definition Langualage | 数据定义语言，用来定义数据库对象(数据库，表，字段)       |
| DML  | Data Manipulation Language | 数据操作语言，用来对数据库表中的数据进行增删改           |
| DQL  | Data Query Language        | 数据查询语言，用来查询数据库中表的记录。                 |
| DCL  | Data Control Language      | 数据控制语言，用来创建数据库用户、控制数据库的访问权限。 |

# DDL语句

## 数据库操作

* 查询
  查询所有数据库：

  ```sql
  SHOW DATABASES;
  ```

  查询当前数据库：

  ```sql
  SELECT DATABASE();
  ```
* 创建数据库：

  ```sql
  CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; 
  ```

  **字符集**常见选项：

  * `utf8`：它支持大部分多语言字符，单每个字符最多使用3个字节。这意味着它不能完整的支持一些复杂的字符，如Emoji。
  * `utf8mb4`：这是MySQL官方推荐的、功能最全的UTF-8字符集。`mb4`代表"most bytes 4"，即每个字符最多可以占用4个字节。这使得它能够完整支持所有Unicode字符，包括Emoji、复杂的汉字、特殊符号。
  * `gbk`：用于简体中文，每个汉字占用两个字节。它只支持简体中文，不支持其他语言的字符。
  * `latin1`：这是MySQL的默认字符集。它只包含西欧语言字符，不支持中文。
  * `ascii`：最基本的字符集，只包含英文字母、数字和一些符号。

  **排序规则**：排序规则是与特定字符集相关联的一组规则，它定义了如何比较和排序字符集中的**字符串**。同一个字符集可以有多种排序规则。以 `utf8mb4`为例：

  * `utf8mb4_general_ci`：这是 `utf8mb4`字符集的一个通用排序规则。`ci`表示不区分大小写。
  * `utf8mb4_unicode_ci`：它基于Unicode标准进行排序。不区分大小写。
  * `utf8mb4_bin`：直接按照字符的二进制值进行比较，因此是区分大小写的。
* 删除：

  ```sql
  DROP DATABASE[IF EXISTS] 数据库名;
  ```
* 使用：

  ```sql
  USE 数据库名;
  ```

## 表操作

### 查询

* 查询当前数据库所有表：

  ```sql
  SHOW TABLES;
  ```
* 查询表结构：

  ```sql
  DESC 表名;
  ```
* 查询指定表的建表语句

  ```sql
  SHOW CREATE TABLE 表名;
  ```

### 创建

* DDL-表操作-创建

  ```sql
  CREATE TABLE 表名(
  	字段1 字段1类型 [COMMENT "字段1注释"],
  	字段2 字段2类型 [COMMENT "字段2注释"],
  	...
  	字段n 字段n类型 [COMMENT "字段n注释"]
  )[COMMENT "表注释"];
  ```

### 修改

* DDL-表操作-添加字段

  ```sql
  ALTER TABLE 表名 ADD 字段名 类型 [COMMENT 注释] [约束];
  ```
* DDL-表操作-修改数据类型

  ```sql
  ALTER TABLE 表名 MODIFY 字段名 新数据类型;
  ```
* DDL-表操作-修改字段名和字段类型

  ```sql
  ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 [COMMENT注释] [约束];
  ```
* DDL-表操作-删除字段

  ```sql
  ALTER TABLE 表名 DROP 字段名;
  ```
* DDL-表操作-修改表名

  ```sql
  ALTER TABLE 表名 RENAME TO 新表名;
  ```

### 删除

* DDL-表操作-删除

  ```sql
  DROP TABLE [IF EXISTS] 表名;
  ```
* DDL-表操作-删除指定表，并重新创建该表(清除表中的数据)

  ```sql
  TRUNCATE TABLE 表名
  ```

### 数据类型

#### 数值类型

| 类型             | 大小 byte | SIGNED范围                                       | UNSIGNED范围              | 描述               |
| ---------------- | --------- | ------------------------------------------------ | ------------------------- | ------------------ |
| `TINYINT`      | 1         | -128~127                                         | 0~255                     | 小整数值           |
| `SMALLINT`     | 2         | -32768~32767                                     | 0~65535                   | 整数值             |
| `MEDIUMINT`    | 3         | -8388608~8388607                                 | 0~16777215                | 整数值             |
| `INT`          | 4         | -2147483648~2147483647                           | 0~4294967295              | 大整数值           |
| `BIGINT`       | 8         | -9223372036854775808~9223372036854775807         | 0~18446744073709551615    | 极大整数值         |
| `FLOAT`        | 4         | -3.402823466E+38~3.402823466E+38                 | 0~3.402823466E+38         | 单精度浮点数值     |
| `DOUBLE`       | 8         | -1.7976931348623157E+308~1.7976931348623157E+308 | 0~1.7976931348623157E+308 | 双精度浮点数值     |
| `DECIMAL(M,D)` | 依赖M,D   | 依赖于M和D的值                                   | 依赖于M和D的值            | 小数值(精确定点数) |

> **关于显示宽度**：
>
> - 对于**整数类型**：括号中的M为**显示宽度**，表示客户端希望显示的**最少字符数**。只有在结合 `ZEROFILL`属性时才有实际意义，否则仅为显示提示。
> - 对于**浮点数类型**：M是数据的总位数(精度)，D是小数点后的位数(标度)。当整数部分长度大于M-D时会插入失败，小数部分长度大于D显示时会被截断。
> - 浮点数类型存储的都是近似值，而不是精确值。在要求高精度时，应该使用 `DECIMAL`。
> - `INT(M)`、`FLOAT(M, D)`、`DOUBLE(M, D)` 等写法以及 `ZEROFILL` 都是 MySQL 特有的语法扩展，不属于 SQL 标准。从 MySQL 8.0.17 开始它们已被标记为弃用（deprecated），在使用时会产生警告，未来可能被移除。使用时建议直接使用 `INT`、`FLOAT`、`DOUBLE` 。
>
>   ![1754565498387](image/SQL语言_20250807_153153/1754565498387.webp)
>
>   经过实测，这几个功能在：8.0.43MySQL中任然可以**生效**。

**DECIMAL(M,D)类型详细说明**：(这个是SQL语言标准，为定点数可以精确表示范围内的数值)

- M的取值范围：1~65，默认值为10
- D的取值范围：0~30，且不能大于M，默认值为0
- 例如：`DECIMAL(5,2)` 可以存储 -999.99 到 999.99

**修饰符**（放在类型后面修饰）：

- `UNSIGNED`：表示为无符号数，不能存储负数
- `ZEROFILL`：用0填充，当数值少于指定位数时，会在左边补0，同时隐含UNSIGNED属性(MySQL独有，且已经**准备弃用**)
- `AUTO_INCREMENT`：自动递增，通常用于主键字段

#### 字符串类型

| 类型           | 大小               | 描述                         |
| :------------- | :----------------- | :--------------------------- |
| `CHAR(M)`    | 0-255 bytes        | 定长字符串                   |
| `VARCHAR(M)` | 0-65535 bytes      | 变长字符串                   |
| `TINYBLOB`   | 0-255 bytes        | 不超过255个字节的二进制数据  |
| `TINYTEXT`   | 0-255 bytes        | 短文本字符串                 |
| `BLOB`       | 0-65535 bytes      | 二进制形式的长文本数据       |
| `TEXT`       | 0-65535 bytes      | 长文本数据                   |
| `MEDIUMBLOB` | 0-16777215 bytes   | 二进制形式的中等长度文本数据 |
| `MEDIUMTEXT` | 0-16777215 bytes   | 中等长度文本数据             |
| `LONGBLOB`   | 0-4294967295 bytes | 二进制形式的极大文本数据     |
| `LONGTEXT`   | 0-4294967295 bytes | 极大文本数据                 |

> M：表示存储的最大**字符数**。

* char类型为定长字符串，存取性能较高。空余部分用空格填充。
* varchar为变长字符串，存取性能较差，但节省空间。
* BLOB类型存储二进制数据，如音频视频等文件，但是文件太大导致存储效率不高，通常使用**文件系统**代替。数据库只存储文件路径或URL。

#### 日期类型

| 类型          | 大小 | 范围                                       | 格式                | 描述                     |
| :------------ | :--- | :----------------------------------------- | :------------------ | :----------------------- |
| `DATE`      | 3    | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值                   |
| `TIME`      | 3    | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持续时间         |
| `YEAR`      | 1    | 1901 至 2155                               | YYYY                | 年份值                   |
| `DATETIME`  | 8    | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| `TIMESTAMP` | 4    | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值，时间戳 |

# DML语句

DML是数据操作语言，用来对数据库中表的**数据记录**进行增删改操作。

## 添加数据

1. 给指定字段添加数据

   ```sql
   INSERT INTO 表名 (字段1, 字段2, ...) VALUES (值1,值2,...);
   ```
2. 给全部字段添加数据

   ```sql
   INSERT INTO 表名 VALUES (值1, 值2, ...);
   ```
3. 批量添加数据

   ```sql
   INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), ...;
   ```

   ```sql
   INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), ...;
   ```

> * 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。
> * 字符串和日期类型数据应该包含在引导中。
> * 插入的数据大小，应该在字段的规定范围内。

## 修改数据

```sql
UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [WHERE 条件];
```

* 如果没有条件，则会修改整个表的数据。

## 删除数据

```sql
DELETE FROM 表名 [WHERE 条件];
```

* 无条件删除整个表
* DELETE语句不能删除某一个字段的值，只能一次删除一行。

### DELETE+JOIN

在DELETE中进行内连接，可以先匹配**两组行**之间的关系，用另一行的数据来决定是否删除当前行。

例如：

```sql
DELETE p1
FROM Person p1
JOIN Person p2
  ON p1.email = p2.email
WHERE p1.id > p2.id;
```

你可以理解为这样两句：

```sql
WITH tmp AS (
    SELECT p1.id
    FROM Person p1, Person p2
    WHERE p1.email = p2.email
      AND p1.id > p2.id
)DELETE
FROM Person p1
WHERE p1.id IN (
    SELECT id
    FROM tmp
    );
```

> 先查询出符合条件的项，然后再删除它。

# DQL语句

DQL是数据查询语言，用来查询数据库中表的记录。

```sql
SELECT
	字段列表
FROM
	表名列表
WHERE
	条件列表
GROUP BY
	分组字段列表
HAVING
	分组后条件列表
ORDER BY
	排序字段列表
LIMIT
	分页参数
```

## 基本查询

1. 查询多个字段

   ```sql
   SELECT 字段1 [AS "别名1"], 字段2 [AS "别名2"], 字段3 [AS "别名3"], ... FROM 表名;
   ```

   ```sql
   SELECT * FROM 表名;
   ```

* AS关键字可省略。

2. 去除重复记录

   ```sql
   SELECT DISTINCT 字段列表 FROM 表名;
   ```

## 条件查询

1. 语法

   ```sql
   SELECT 字段列表 FROM 表名 WHERE 条件;
   ```

### SQL 比较运算符对照表

| 比较运算符              | 功能                                               |
| ----------------------- | -------------------------------------------------- |
| `>`                   | 大于                                               |
| `>=`                  | 大于等于                                           |
| `<`                   | 小于                                               |
| `<=`                  | 小于等于                                           |
| `=`                   | 等于                                               |
| `<>` 或 `!=`        | 不等于                                             |
| `BETWEEN ... AND ...` | 在某个范围之内（含最小、最大值）                   |
| `IN (...)`            | 在 `IN` 之后的列表中的值，多选一                 |
| `LIKE` "占位符"       | 模糊匹配（`_` 匹配单个字符，`%` 匹配任意字符） |
| `IS NULL`             | 是 `NULL`                                        |

| 逻辑运算符        | 功能                     |
| ----------------- | ------------------------ |
| `AND` 或 `&&` | 并且（多个条件同时成立） |
| `OR` 或 `\|\|`  | 或（一个条件成立即可）   |
| `NOT` 或 `!`  | 非，不是                 |

## 聚合查询

将**一列**数据作为一个整体，进行纵向计算。

```sql
SELECT 聚合函数(字段列表) FROM 表名;
```

* `null`值不参与所有聚合函数运算。

### 常见聚合函数

| 函数        | 描述                     | 示例用法                           |
| ----------- | ------------------------ | ---------------------------------- |
| `COUNT()` | 统计行数（可选字段或 *） | `SELECT COUNT(*) FROM users;`    |
| `SUM()`   | 计算数值字段的总和       | `SELECT SUM(salary) FROM staff;` |
| `AVG()`   | 计算数值字段的平均值     | `SELECT AVG(score) FROM exams;`  |
| `MAX()`   | 获取字段中的最大值       | `SELECT MAX(age) FROM people;`   |
| `MIN()`   | 获取字段中的最小值       | `SELECT MIN(price) FROM goods;`  |

> 一个小注意事项：当你用MIN()、MAX()方法获取字段的最小值时，**其他字段**并不一定为对应最小/最大对象的值。可能为表中随机一个值。

```sql
SELECT delivery_id, MIN(order_date) mindate
FROM Delivery
GROUP BY customer_id
```

只有 `order_date`字段为最小值，但是 `delivery_id`字段并不一定是最小日期项**对应**的 `delivery_id`。

#### GROUP_CONCAT

把同一分组内的多行值拼接成单个字符串

```sql
GROUP_CONCAT(
    [DISTINCT] 表达式
    [ORDER BY 排序字段 [ASC|DESC]]
    [SEPARATOR '分隔符']
)
```

默认**逗号**分割。

## 分组查询

```sql
SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分钟后过滤条件];
```

WHERE 与HAVING 的区别：

* 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。

执行顺序：

* WHERE >聚合函数>HAVING

## 排序查询

```sql
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;
```

排序方式：

* ASC：升序(默认值)(可省略)
* DESC：降序

## 分页查询

```sql
SELECT 字段列表 FROM LIMIT 起始索引, 查询记录数;
```

* 起始索引从0开始，起始索引= (查询页码 - 1) * 每页显示记录数。
* 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是 `LIMIT`
* 如果查询的是第一页的数据，起始索引可以省略。

### limit取第n高的数

只要最高分：

```sql
limit 1;
```

要第3高分：

```sql
limit 2, 1;
```

> 偏移两个，再获取一个数据。

## 执行顺序

FROM -> WHERE ->GROUP BY -> SELECT -> HAVING -> ORDER BY LIMIT.

## CET

在 SQL 中，CTE 是一个 **临时命名的结果集** ，只在当前语句执行期间有效。

作用：让复杂查询分步骤写，提升可读性和可维护性。

特点：

* 用 `WITH` 关键字定义
* 可以被后续的 `SELECT` / `INSERT` / `UPDATE` / `DELETE` / `MERGE` 引用
* 支持递归（递归 CTE）

```sql
WITH cte_name (col1, col2, ...)
AS (
    -- 定义 CTE 的查询
    SELECT ...
    FROM ...
    WHERE ...
)
SELECT *
FROM cte_name;
```

### 单个CET

示例：生成左表头用于数据分类统计

员工收入表：

```
+------------+--------+
| account_id | income |
+------------+--------+
| 3          | 108939 |
| 2          | 12747  |
| 8          | 87709  |
| 6          | 91796  |
+------------+--------+
```

我们想要按照如下标准分类，并统计每个分类的数量：

* `"Low Salary"`：所有工资 **严格低于** `20000` 美元。
* `"Average Salary"`： **包含** 范围内的所有工资 `[$20000, $50000]` 。
* `"High Salary"`：所有工资 **严格大于** `50000` 美元。

```sql
WITH c AS (SELECT 'Low Salary' AS category
           UNION ALL
           SELECT 'Average Salary'
           UNION ALL
           SELECT 'High Salary')
SELECT category, COUNT(l.level) accounts_count
FROM (SELECT *,
             CASE
                 WHEN income < 20000 THEN 'Low Salary'
                 WHEN (income >= 20000 AND income <= 50000) THEN 'Average Salary'
                 ELSE 'High Salary' END level
      FROM Accounts) AS l
         RIGHT JOIN c
                    ON l.level = c.category

GROUP BY c.category
;
```

**CTE递归**：

```sql
WITH RECURSIVE cte_name AS (
    -- ① 锚点查询（Anchor Member）：初始数据
    SELECT ...
    FROM ...
    WHERE ...   -- 起点条件

    UNION ALL

    -- ② 递归成员（Recursive Member）：引用自己
    SELECT ...
    FROM cte_name
    JOIN ...
    WHERE ...   -- 递归条件
)
-- ③ 主查询：使用递归结果
SELECT * FROM cte_name;
```

 **执行流程** ：

1. 先运行锚点查询，得到初始结果集。
2. 把结果集传给递归成员查询，生成下一层数据。
3. 不断重复，直到递归成员不再返回新行。
4. 合并所有层的结果返回。

### 多个CET

SQL查询可以创建多个CET表

```sql
WITH table1 AS (...),
     table2 AS (...),
     table3 AS (...)
SELECT ...
FROM ...
;
```

后声明的表可以引用先声明的表。以达到层层递进的效果。

# DCL

DCL是数据控制语言，用来管理数据库用户、控制数据库的**访问权限**。

### 创建用户

mysql的用户由两部分组成：`'用户名'@'主机名'`

这意味着 `'alice'@'localhost'` 与 `'alice'@'192.168.1.100'` 是两个完全独立的用户，它们可以拥有不同的密码、权限和访问范围。

1. 查询用户

   用户数据存储在mysql数据库中的user表中

   ```sql
   USE mysql;
   SELECT * FROM user;
   ```
2. 创建用户

   ```sql
   CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
   ```

   使用 `%`代替主机名，表示任意IP的主机可以访问。
3. 修改用户密码

   ```sql
   ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';
   ```
4. 删除用户

   ```sql
   DROP USER '用户名'@'主机名';
   ```

### 权限控制

常用权限：

| 权限                    | 说明               |
| :---------------------- | :----------------- |
| `ALL, ALL PRIVILEGES` | 所有权限           |
| `SELECT`              | 查询数据           |
| `INSERT`              | 插入数据           |
| `UPDATE`              | 修改数据           |
| `DELETE`              | 删除数据           |
| `ALTER`               | 修改表             |
| `DROP`                | 删除数据库/表/视图 |
| `CREATE`              | 创建数据库/表      |

1. 查询用户权限

   ```sql
   SHOW GRANTS FOR '用户名'@'主机名';
   ```
2. 授予权限

   ```sql
   GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
   ```
3. 撤销权限

   ```sql
   REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
   ```

* 多个权限之间，使用 `,`分割
* 授权时，数据库名和表名可以使用**`*`**进行通配，代表所有。

# 函数

函数是指一段可以直接被另一程段程序调用的程序或代码。

## 字符串函数

MySQL中内置了很多字符串函数，常用的几个如下：

|             函数             | 功能                                                      |
| :--------------------------: | :-------------------------------------------------------- |
|   `CONCAT(S1,S2,...Sn)`   | 字符串拼接，将S1，S2，...Sn拼接成一个字符串               |
|        `LOWER(str)`        | 将字符串str全部转为小写                                   |
|        `UPPER(str)`        | 将字符串str全部转为大写                                   |
|     `LPAD(str,n,pad)`     | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |
|     `RPAD(str,n,pad)`     | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 |
|        `TRIM(str)`        | 去掉字符串**头部**和**尾部**的空格            |
| `SUBSTRING(str,start,len)` | 返回从字符串str从start位置起的len个长度的字符串           |

> * SUBSTRING函数的下标从1开始。

## 数值函数

 常见的数值函数如下：

| 函数           | 功能                               |
| :------------- | :--------------------------------- |
| `CEIL(x)`    | 向上取整                           |
| `FLOOR(x)`   | 向下取整                           |
| `MOD(x,y)`   | 返回 `x % y` 的值                |
| `RAND()`     | 返回0~1内的随机数                  |
| `ROUND(x,y)` | 求参数x的四舍五入的值，保留y位小数 |

## 日期函数

常见的日期函数如下：

| 函数                                   | 功能                                                |
| :------------------------------------- | :-------------------------------------------------- |
| `CURDATE()`                          | 返回当前日期                                        |
| `CURTIME()`                          | 返回当前时间                                        |
| `NOW()`                              | 返回当前日期和时间                                  |
| `YEAR(date)`                         | 获取指定date的年份                                  |
| `MONTH(date)`                        | 获取指定date的月份                                  |
| `DAY(date)`                          | 获取指定date的日期                                  |
| `DATE_ADD(date, INTERVAL expr type)` | 返回一个日期/时间值加上一个时间间隔expr后的时间值   |
| `DATEDIFF(date1,date2)`              | 返回 `date1`减去 `date2`之间的天数              |
| `DATE_FORMAT(date, format)`          | 按照指定的 `format`格式化 `date`值如：`%Y-%m` |

## 流程函数

流程函数也是很常用的一类函数，可以在SQL语句中实现**条件筛选**，从而提高语句的效率。

| 函数                                                           | 功能                                                      |
| :------------------------------------------------------------- | :-------------------------------------------------------- |
| `IF(value,t,f)`                                              | 如果value为true，则返回t；否则返回f                       |
| `IFNULL(value1,value2)`                                      | 如果value1不为空，返回value1；否则返回value2              |
| `CASE WHEN [val1] THEN [res1] ... ELSE [default] END`        | 如果val为true，返回res1，... 否则返回default默认值        |
| `CASE [expr] WHEN [val1] THEN [res1] ... ELSE [default] END` | 如果expr的值等于val1，返回res1，... 否则返回default默认值 |

## 窗口函数

保留原有所有行，每行基于指定“窗口”计算一个值。

| 函数类别   | 常用函数          | 功能说明                                  | 常见用途                   | 示例                                                             |
| ---------- | ----------------- | ----------------------------------------- | -------------------------- | ---------------------------------------------------------------- |
| 排序与排名 | `ROW_NUMBER()`  | 按指定顺序为每行生成唯一序号（不重复）    | 去重取第一条记录、分页查询 | `ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC)`   |
|            | `RANK()`        | 按顺序排名，相同值并列，后续名次会跳过    | 比赛排名、统计并列名次     | `RANK() OVER (ORDER BY score DESC)`                            |
|            | `DENSE_RANK()`  | 与 `RANK()` 类似，但名次不跳过          | 班级并列成绩排名           | `DENSE_RANK() OVER (ORDER BY score DESC)`                      |
| 累计与聚合 | `SUM()`         | 在窗口内求和                              | 累计销售额、滚动求和       | `SUM(sales) OVER (PARTITION BY region ORDER BY month)`         |
|            | `AVG()`         | 在窗口内取平均值                          | 统计区间均值               | `AVG(score) OVER (PARTITION BY class)`                         |
|            | `COUNT()`       | 在窗口内计数                              | 统计分组记录数             | `COUNT(*) OVER (PARTITION BY dept)`                            |
| 取前后值   | `LAG()`         | 获取当前行之前第 n 行的值                 | 同环比分析、趋势对比       | `LAG(sales, 1) OVER (ORDER BY month)`                          |
|            | `LEAD()`        | 获取当前行之后第 n 行的值                 | 预测下一期数据             | `LEAD(sales, 1) OVER (ORDER BY month)`                         |
| 边界值     | `FIRST_VALUE()` | 获取窗口内排序后的第一行值                | 获取某分组最早/最低数据    | `FIRST_VALUE(salary) OVER (PARTITION BY dept ORDER BY salary)` |
|            | `LAST_VALUE()`  | 获取窗口内排序后的最后一行值              | 获取某分组最新/最高数据    | `LAST_VALUE(salary) OVER (PARTITION BY dept ORDER BY salary)`  |
| 偏移计算   | `NTILE(n)`      | 将结果集划分为 n 份，返回每行所属区间编号 | 分位数统计                 | `NTILE(4) OVER (ORDER BY salary DESC)`                         |

* **OVER 子句** 是窗口函数的关键，可搭配：
  * `PARTITION BY`：按组划分窗口
  * `ORDER BY`：定义窗口内的排序
  * `ROWS/RANGE`：指定窗口的行范围

# 约束

* **概念**：约束是作用于表中字段上的规则，用于限制存储在表中的数据。
* **目的**：保证数据库中数据的正确、有效和完整。

| 约束                      | 描述                                                     | 关键字      |
| :------------------------ | :------------------------------------------------------- | :---------- |
| 非空约束                  | 限制该字段的数据不能为null                               | NOT NULL    |
| 唯一约束                  | 保证该字段的所有数据都是唯一、不重复的                   | UNIQUE      |
| 主键约束                  | 主键是一行数据的唯一标识，要求非空且唯一                 | PRIMARY KEY |
| 默认约束                  | 保存数据时，如果未指定该字段的值，则采用默认值           | DEFAULT     |
| 检查约束 (8.0.16版本之后) | 保证字段值满足指定条件                                   | CHECK       |
| 外键约束                  | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |

> 约束是作用于表中字段上的，可以在创建表/修改表的时间添加约束。

> 一个字段可以添加多个约束。

示例：

![1755004721798](image/SQL语言_20250807_153153/1755004721798.webp)

```sql
CREATE TABLE User(
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT '唯一标识',
    name VARCHAR(10) NOT NULL UNIQUE COMMENT '姓名',
    age INT CHECK ( age > 0 AND age <= 120 ) COMMENT '年龄',
    status char(1) DEFAULT '1' COMMENT '状态',
    gender char(1) COMMENT '性别'
);
```

## 外键约束

外键将一个表中的列与另一个表的主键（或唯一键）关联起来，从而形成父子关系。

添加外键：

* 创建时添加：

  ```sql
  CREATE TABLE 表名(
  	字段名 数据类型,
  	...
  	[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)
  );
  ```
* 创建后添加：

  ```sql
  ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);
  ```

删除外键：

```sql
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
```

删除/更新行为：

| 行为        | 说明                                                                                                                              |
| :---------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果没有则不允许删除/更新。（与 RESTRICT 一致）(**默认行为**)) |
| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果没有则不允许删除/更新。（与 NO ACTION 一致）                     |
| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。                            |
| SET NULL    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许null）。         |
| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)                                                                       |

```sql
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;
```

# 多表查询

## 多表关系

项目开发中，在进行数据库表结构设计时，会根据业务需求以及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：

* 一对多(多对一)
* 多对多
* 一对一

### 一对多

案例：部门 与 员工的关系

关系：**一个部门**对应**多个员工**；一个员工对应一个部门。

实现：在多的一方建立外键，指向一的一方的主键。

![1755051500177](image/SQL语言_20250807_153153/1755051500177.webp)

### 多对多

案例：学生 与 课程的关系

关系：**一个学生**可以选修**多门课程**，**一个课程**可以供多个。

实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。

![1755051706816](image/SQL语言_20250807_153153/1755051706816.webp)

### 一对一

案例：用户 与 用户详情的关系

关系：一对一关系，用于单表拆分，将一张表的**基础字段**放在一张表中，其他**详情字段**放在另一张表中，以提升操作效率。

实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的(UNIQUE)。

![1755052258912](image/SQL语言_20250807_153153/1755052258912.webp)

## 多表查询概述

 从多张表中查询数据。

多表查询分类：

* 连接查询：
  * 内连接：查询A, B交集部分数据。
  * 外连接：
    * 左外连接：查询左表所有数据，以及两张表交集部分数据。
    * 右外连接：查询右表所有数据，以及两张表交集部分数据。
  * 自连接：当前表与自身的连接查询，自连接必须使用表别名。
* 子查询

## 内连接

内连接只会显式**交集部分**的数据。

* 隐式内连接：

  ```sql
  SELECT 字段列表 FROM 表1, 表2 WHERE 条件...;
  ```
* 显式内连接：

  ```sql
  SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件...;
  ```

## 外连接

外连接可以查到左表或右表的所有数据。

* 左外连接：

  ```sql
  SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件...;
  ```

  > 相等于查询表1(左表)的**所有数据** 包含表1和表2交集部分的数据。
  >
* 右外查询：

  ```sql
  SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...;
  ```

  > 相当于查询表2(右表)的所有数据 包含 表1 和 表2 交集部分的数据。
  >
* 笛卡尔积

  ```sql
  SELECT 字段列表 FROM 表1 CROSS JOIN 表2;
  ```

## 自连接

 自连接查询可以是内连接，也可以是外连接。

```sql
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;
```

> 当前表与自身的连接查询，自连接必须使用表别名。

## 联合查询

对于union查询，就是把多次查询结果合并起来，形成一个新的查询结果集。

```sql
SELECT 字段列表 FROM 表A ...
UNION [ALL]
SELECT 字段列表 FROM 表B ...;
```

* 有 `ALL `关键字不会进行自动去重。
* 表A与表B的**查询字段**必须完全相同，否则会报错。

## 子查询

**子查询（Subquery）** 是嵌套在其他 SQL 语句中的查询语句，通常用于在主查询中提供中间结果。它可以出现在 `SELECT`、`FROM`、`WHERE`、`HAVING` 等子句中。

* **基本示例** ：

```sql
  SELECT *
  FROM t1
  WHERE column1 = (SELECT column1 FROM t2);
```

子查询的分类与用途

* 按结果分：

| 类型                 | 返回结果           | 场景举例                              |
| -------------------- | ------------------ | ------------------------------------- |
| **标量子查询** | 单个值             | 比较运算，如 `=`、`>`             |
| **列子查询**   | 一列（多行）       | 用于 `IN`、`ANY`、`ALL`         |
| **行子查询**   | 一行（多列）       | 用于多列比较 `(col1, col2) = (...)` |
| **表子查询**   | 多行多列（临时表） | 常放在 `FROM`后做中间结果集         |

* 按位置分：

| 位置                  | 示例                                 | 用途         |
| --------------------- | ------------------------------------ | ------------ |
| **WHERE 之后**  | 过滤条件中使用子查询                 | 条件筛选     |
| **FROM 之后**   | 将子查询结果当作临时表（派生表）使用 | 中间计算     |
| **SELECT 之后** | 作为列计算的来源                     | 动态计算字段 |

### 标量子查询

子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询。

* 常用操作符：`=`、`!=`、`>=`、`>`、`<`、`<=`

WHERE 子句中的标量子查询 ：

```sql
SELECT name
FROM employees
WHERE dept_id = (
    SELECT id FROM departments WHERE name = '研发部'
);
```

### 列子查询

子查询返回的结果是**一列**(可能是多行)，这种子查询称为列子查询。

常用操作符：`IN`、`NOT IN`、`ANY`、`SOME`、`ALL`

| 操作符 | 描述                                        |
| ------ | ------------------------------------------- |
| IN     | 在指定的集合范围之内，多选一                |
| NOT IN | 不在指定的集合范围之内                      |
| ANY    | 子查询返回列表中，有任意一个满足即可        |
| SOME   | 与 ANY 等同，使用 SOME 的地方都可以使用 ANY |
| ALL    | 子查询返回列表的所有值都必须满足            |

```sql
SELECT * 
FROM emp 
WHERE salary > ALL (
    SELECT salary 
    FROM emp 
    WHERE dept_id = (
        SELECT id 
        FROM dept 
        WHERE name = '财务部'
    )
);
```

### 行子查询

子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。

常用操作符：`=`、`!=`、`IN`、`NOT`、`IN`

```sql
-- 查询与 "张无忌" 的薪资及直属领导相同的员工信息；
SELECT * 
FROM emp 
WHERE (salary, managerid) = (
    SELECT salary, managerid 
    FROM emp 
    WHERE name = '张无忌'
);

```

### 表子查询

子查询返回的结果是多行多列，这种子查询称为表子查询。

常用操作符：`IN`

```sql
SELECT e.*, d.* 
FROM (
    SELECT * 
    FROM emp 
    WHERE entrydate > '2006-01-01'
) e 
LEFT JOIN dept d 
    ON e.dept_id = d.id;
```

# 事务

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**。

## 事务操作

* 查看事务提交方式

  ```sql
  SELECT @@autocommit;
  ```

  ![1755223381443](image/SQL语言_20250807_153153/1755223381443.webp)

  1为自动提交开启，0为关闭。
* 设置事务提交方式

  ```sql
  SET @@autocommit=0;
  ```
* 提交事务：将本次修改进行提交

  ```sql
  COMMIT;
  ```
* 回滚事务：回滚到上次提交事务的状态

  ```sql
  ROLLBACE;
  ```
* 开启事务

  ```sql
  START TRANSACTION;
  ```

> 开启事务后，执行到COMMIT或ROLLBACK 就算事务结束。

## 事务四大特性

* **原子性**(Atomicity)：**原子性** 意味着一个事务中的所有操作，要么全部完成，要么全部失败回滚， **不可分割** 。
* **一致性**(Consistency)：**一致性** 确保事务执行前后，数据库从一个**合法状态**转移到另一个 **合法状态** 。
* **隔离性**(Isolation)：**隔离性** 指的是一个事务的执行不应该被其他事务干扰。
* **持久性**(Durability)：**持久性** 意味着一旦事务 **提交（commit）** ，它对数据库的更改就是永久性的，即使系统发生故障（如断电或系统崩溃），这些更改也不会丢失。

## 并发事务问题

| 问题                 | 描述                                                                                                     |
| -------------------- | -------------------------------------------------------------------------------------------------------- |
| **脏读**       | 一个事务读到另外一个事务还没有提交的数据。                                                               |
| **不可重复读** | 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。                                     |
| **幻读**       | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影。 |

## 事务的隔离级别

| 隔离级别 (Isolation Level) | 脏读 (Dirty Read) | 不可重复读 (Non-repeatable Read) | 幻读 (Phantom Read) |
| -------------------------- | ----------------- | -------------------------------- | ------------------- |
| Read uncommitted           | √                | √                               | √                  |
| Read committed             | ×                | √                               | √                  |
| Repeatable Read (默认)     | ×                | ×                               | √                  |
| Serializable               | ×                | ×                               | ×                  |

> * ×——表示不会发生， √表示有可能发生
> * 从上到下越发安全，但性能越差

```sql
-- 查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION

-- 设置事务隔离级别
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL 隔离级别
```

# 数据库优化

## 数据库索引

索引是一种 **数据结构** ，用于帮助数据库 **高效获取数据** 。

本质：

* 索引的本质是 **额外维护的有序结构** （如 B+ 树、哈希表、二叉树等）。
* 优点：

  * 查询速度快
  * 减少 I/O 操作
  * 通过索引列对数据进行排序，降低数据排序成本
* 缺点：

  * 占用额外存储空间
  * 插入、更新、删除时需要**维护索引**

> 没有创建索引时，mysql进行**全表扫描**。数据量大时，速度非常慢。

### 结构

**MySQL 支持的索引类型** ：

* **Hash 索引** ：基于哈希表，等值查询快，不支持范围查询。
* **B+Tree 索引** （默认）：有序结构，支持范围查询、排序等。
* **Full-Text 索引** ：全文检索，用于文本匹配。

**默认情况** ：如果没有特别说明，MySQL 中的“索引”一般指  **B+Tree 索引** 。

![1756087107673](image/SQL语言_20250807_153153/1756087107673.webp)

### 语法

> * 主键字段，在建表时，会自动创建主键索引
> * 添加唯一约束时，数据库实际上会添加唯一索引

创建索引：

```sql
CREATE [UNIQUE] INDEX 索引名 ON 表名 (字段名, ...);
```

* **`UNIQUE`** ：可选，表示创建唯一索引（字段值不能重复）。
* **索引名** ：自定义，建议有含义（如 `idx_user_age`）。
* **字段名** ：可为单列或多列（组合索引）。

查看索引：

```sql
SHOW INDEX FROM 表名;
```

* 返回结果包含：
  * **Key_name** ：索引名
  * **Column_name** ：索引字段
  * **Non_unique** ：是否唯一（0 表示唯一）
  * **Seq_in_index** ：字段在索引中的顺序
  * **Cardinality** ：基数（区分度）

删除索引：

```sql
DROP INDEX 索引名 ON 表名;
```

* 注意：
  * 删除索引不会删除数据。
  * 删除后相关查询可能变慢。
